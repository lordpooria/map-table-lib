{"version":3,"sources":["../../src/store/store.ts"],"names":["tdStoreModel","tdVersion","lowerLimitIndex","upperLimitIndex","loadingTimeIndex","currentTimeIndex","currentTime","currentData","users","numberNextTimesReady","formattedData","availableTimes","syncedLayers","setTimeloadingIndex","state","newTimeIndex","setNewTimeIndex","time","setData","setAvailableTime","times","mode","period","_availableTimes","undefined","lowerLimitTime","upperLimitTime","setCurrentTime","actions","helper","getState","index","setCurrentTimeIndex","upperLimit","length","lowerLimit","Math","min","max","nextTime","numSteps","loop","newIndex","previousTime","prepareNextTimes","howmany","currentIndex","i","len","setMinimumForwardCache","count","getNumberNextTimesReady","ready","prepareAvailableTimes","updateCurrentTime","updateTimeDimensionMode","_updateCurrentTime","store"],"mappings":"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","sourcesContent":["import { action, Action, createStore, thunk, Thunk } from \"easy-peasy\";\nimport {\n  AvailableTimes,\n  FormattedData,\n  CurrentData,\n  Mode,\n  Period,\n  SyncedLayer,\n  Users,\n} from \"../types/common\";\n\nimport {\n  seekNearestTimeIndex,\n  getLowerLimit,\n  getUpperLimit,\n  setAvailableTime,\n  checkSyncedLayersReady,\n} from \"./util\";\n\nexport interface TDStoreModel {\n  tdVersion: string;\n  lowerLimitIndex: number;\n  upperLimitIndex: number;\n  loadingTimeIndex: number;\n  currentTimeIndex: number;\n  currentTime: number;\n  currentData: CurrentData | null;\n  users: Users | null;\n  formattedData: FormattedData;\n\n  numberNextTimesReady: number;\n  availableTimes: AvailableTimes;\n  syncedLayers: SyncedLayer;\n  setTimeloadingIndex: Action<TDStoreModel, { newTimeIndex: number }>;\n  setNewTimeIndex: Action<TDStoreModel>;\n\n  prepareNextTimes: Action<\n    TDStoreModel,\n    { numSteps: number; howmany: number; loop: boolean }\n  >;\n\n  getNumberNextTimesReady: Action<\n    TDStoreModel,\n    { numSteps: number; howmany: number; loop: boolean }\n  >;\n\n  setAvailableTime: Action<\n    TDStoreModel,\n    {\n      times?: AvailableTimes;\n      mode: Mode;\n      period: Period;\n    }\n  >;\n\n  setData: Action<TDStoreModel, { formattedData: FormattedData; users: Users }>;\n\n  setCurrentTimeIndex: Thunk<\n    TDStoreModel,\n    { index: number /* loadingTimeout: number */ }\n  >;\n  setCurrentTime: Thunk<\n    TDStoreModel,\n    { time: number /* loadingTimeout: number */ }\n  >;\n  nextTime: Thunk<\n    TDStoreModel,\n    { numSteps: number; loop: boolean /* loadingTimeout: number */ }\n  >;\n  previousTime: Thunk<\n    TDStoreModel,\n    { numSteps: number; loop: boolean /* loadingTimeout: number */ }\n  >;\n  prepareAvailableTimes: Thunk<\n    TDStoreModel,\n    {\n      _availableTimes: AvailableTimes;\n      updateCurrentTime: boolean;\n      // updateTimeDimension: boolean;\n      updateTimeDimensionMode: Mode;\n      /* loadingTimeout: number;*/\n    }\n  >;\n}\n\nexport const tdStoreModel: TDStoreModel = {\n  tdVersion: \"1.0.0\",\n\n  lowerLimitIndex: 0,\n  upperLimitIndex: 0,\n  loadingTimeIndex: -1,\n  currentTimeIndex: -1,\n  currentTime: -1,\n  currentData: null,\n  users: null,\n  numberNextTimesReady: 0,\n  formattedData: [],\n  availableTimes: [],\n  syncedLayers: [],\n  setTimeloadingIndex: action((state, { newTimeIndex }) => {\n    state.loadingTimeIndex = newTimeIndex;\n  }),\n\n  setNewTimeIndex: action((state) => {\n    if (state.loadingTimeIndex === -1) {\n      return;\n    }\n    state.currentData = state.formattedData[state.loadingTimeIndex];\n    state.currentTime = state.formattedData[state.loadingTimeIndex].time;\n    state.currentTimeIndex = state.loadingTimeIndex;\n    // console.log(\"END -- Current time: \" + new Date(time).toISOString());\n\n    state.loadingTimeIndex = -1;\n  }),\n\n  setData: action((state, { formattedData, users }) => {\n    state.formattedData = formattedData;\n    state.users = users;\n  }),\n  setAvailableTime: action((state, { times, mode, period }) => {\n    const _availableTimes = setAvailableTime(\n      mode,\n      times,\n      period,\n      state.availableTimes\n    );\n    if (_availableTimes !== undefined) state.availableTimes = _availableTimes;\n\n    if (state.lowerLimitIndex) {\n      const lowerLimitTime = state.availableTimes[state.lowerLimitIndex];\n      state.lowerLimitIndex = getLowerLimit(\n        lowerLimitTime,\n        state.upperLimitIndex,\n        state.availableTimes\n      );\n    }\n    if (state.upperLimitIndex) {\n      const upperLimitTime = state.availableTimes[state.upperLimitIndex];\n      state.upperLimitIndex = getUpperLimit(\n        upperLimitTime,\n        state.upperLimitIndex,\n        state.availableTimes\n      );\n    }\n  }),\n\n  setCurrentTime: thunk((actions, { time }, helper) => {\n    const state = helper.getState();\n    var index = seekNearestTimeIndex(time, state.formattedData);\n\n    actions.setCurrentTimeIndex({ index });\n  }),\n\n  setCurrentTimeIndex: thunk((actions, { index }, helper) => {\n    const state = helper.getState();\n    var upperLimit = state.upperLimitIndex || state.formattedData.length - 1;\n    var lowerLimit = state.lowerLimitIndex || 0;\n    //clamp the value\n    const newTimeIndex = Math.min(Math.max(lowerLimit, index), upperLimit);\n\n    if (newTimeIndex < 0) {\n      return;\n    }\n    actions.setTimeloadingIndex({ newTimeIndex });\n    // const newTime = state.availableTimes[newTimeIndex];\n    // console.log(\"INIT -- Current time: \" + new Date(newTime).toISOString());\n    // if (\n    //   checkSyncedLayersReady(\n    //     state.availableTimes[state.loadingTimeIndex],\n    //     state.syncedLayers\n    //   )\n    // ) {\n    actions.setNewTimeIndex();\n    // } else {\n    //   // add timeout of 3 seconds if layers doesn't response\n    //   setTimeout(actions.setNewTimeIndex, 3000);\n    // }\n  }),\n\n  nextTime: thunk((actions, { numSteps, loop }, helper) => {\n    const state = helper.getState();\n\n    if (!numSteps) {\n      numSteps = 1;\n    }\n    let newIndex = state.currentTimeIndex;\n    var upperLimit = state.upperLimitIndex || state.formattedData.length - 1;\n    var lowerLimit = state.lowerLimitIndex || 0;\n    if (state.loadingTimeIndex > -1) {\n      newIndex = state.loadingTimeIndex;\n    }\n    newIndex = newIndex + numSteps;\n    if (newIndex > upperLimit) {\n      if (!!loop) {\n        newIndex = lowerLimit;\n      } else {\n        newIndex = upperLimit;\n      }\n    }\n    // loop backwards\n    if (newIndex < lowerLimit) {\n      if (!!loop) {\n        newIndex = upperLimit;\n      } else {\n        newIndex = lowerLimit;\n      }\n    }\n    actions.setCurrentTimeIndex({ index: newIndex });\n  }),\n\n  previousTime: thunk((actions, { numSteps, loop }) => {\n    actions.nextTime({ numSteps: numSteps * -1, loop });\n  }),\n\n  prepareNextTimes: action((state, { numSteps, howmany, loop }) => {\n    if (!numSteps) {\n      numSteps = 1;\n    }\n\n    let newIndex = state.currentTimeIndex;\n    var currentIndex = newIndex;\n    if (state.loadingTimeIndex > -1) {\n      newIndex = state.loadingTimeIndex;\n    }\n    // assure synced layers have a buffer/cache of at least howmany elements\n    for (var i = 0, len = state.syncedLayers.length; i < len; i++) {\n      if (state.syncedLayers[i].setMinimumForwardCache) {\n        state.syncedLayers[i].setMinimumForwardCache(howmany);\n      }\n    }\n    var count = howmany;\n    const upperLimit: number =\n      state.upperLimitIndex || state.formattedData.length - 1;\n    const lowerLimit: number = state.lowerLimitIndex || 0;\n    while (count > 0) {\n      newIndex = newIndex + numSteps;\n      if (newIndex > upperLimit) {\n        if (!!loop) {\n          newIndex = lowerLimit;\n        } else {\n          break;\n        }\n      }\n      if (newIndex < lowerLimit) {\n        if (!!loop) {\n          newIndex = upperLimit;\n        } else {\n          break;\n        }\n      }\n      if (currentIndex === newIndex) {\n        //we looped around the timeline\n        //no need to load further, the next times are already loading\n        break;\n      }\n      state.loadingTimeIndex = newIndex;\n      // timeloading({ newTime: availableTimes[newIndex] });\n      // fire(\"timeloading\", {\n      //   time: _availableTimes[newIndex],\n      // });\n      count--;\n    }\n  }),\n\n  getNumberNextTimesReady: action((state, { numSteps, howmany, loop }) => {\n    if (!numSteps) {\n      numSteps = 1;\n    }\n\n    var newIndex = state.currentTimeIndex;\n    if (state.loadingTimeIndex > -1) {\n      newIndex = state.loadingTimeIndex;\n    }\n    var count = howmany;\n    var ready = 0;\n    var upperLimit = state.upperLimitIndex || state.availableTimes.length - 1;\n    var lowerLimit = state.lowerLimitIndex || 0;\n    while (count > 0) {\n      newIndex = newIndex + numSteps;\n      if (newIndex > upperLimit) {\n        if (!!loop) {\n          newIndex = lowerLimit;\n        } else {\n          count = 0;\n          ready = howmany;\n          break;\n        }\n      }\n      if (newIndex < lowerLimit) {\n        if (!!loop) {\n          newIndex = upperLimit;\n        } else {\n          count = 0;\n          ready = howmany;\n          break;\n        }\n      }\n      var time = state.availableTimes[newIndex];\n      if (checkSyncedLayersReady(time, state.syncedLayers)) {\n        ready++;\n      }\n      count--;\n    }\n    state.numberNextTimesReady = ready;\n  }),\n\n  prepareAvailableTimes: thunk(\n    (\n      actions,\n      { _availableTimes, updateCurrentTime, updateTimeDimensionMode },\n      helper\n    ) => {\n      const state = helper.getState();\n      const _updateCurrentTime =\n        updateCurrentTime || state.availableTimes.length == 0;\n      if (_updateCurrentTime || state.availableTimes.length == 0) {\n        actions.setAvailableTime({\n          times: _availableTimes,\n          mode: updateTimeDimensionMode,\n          period: \"\",\n        });\n      }\n      if (_updateCurrentTime && _availableTimes.length) {\n        actions.setCurrentTime({ time: _availableTimes[0] });\n      }\n    }\n  ),\n};\n\n// const nodeEnv: string = (typeof process?.__ENV__ !== 'undefined' && __ENV__) as string;\nconst store = createStore(tdStoreModel);\n\nexport default store;\n"],"file":"store.js"}